
;; storage : {
;;   slice name,
;;   slice symbol,
;;   uint8 decimals,
;;   uint256 supply,
;;   uint256 total_lp_supply,
;;   token_reserves supply,
;;   ton_reserves supply,
;;   balances : {
;;     slice address : uint256 amount
;;   },
;;   approvals : {
;;     slice sender : {
;;       slice spender: uint256 amount
;;     }
;;   }
;;   uint8 initialised 
;;   }

;; ============= actions ====================
;; transfer = 1 TRC20 
;; transfer_from = 2 TRC20 
;; increase/decrease = 3 TRC20
;; claim_rewards = 4 claim_rewards
;; add_liqiuidity = 5 mint lp token 
;; remove_liqiuidity = 6 burn lp token
;; Swap In = 7  TON -> Token
;; Swap Out = 8 Token -> TON

builder store_builder(builder to, builder what) asm(what to) "STB";
builder store_builder_ref(builder to, builder what) asm(what to) "STBREFR";
(cell, int) dict_delete?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDEL";
(slice, int) dict_get?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTGET" "NULLSWAPIFNOT";

global slice my_address_x; ;; Testing , this a replacemnet my_address()
global int now_x; ;; this a replacement for block_lt()

;; =============== GAS Functions =============================

int cell_storage_fee() asm "10000000 PUSHINT"; ;; 0.01 TON
int gas_to_coins(int workchain, int gas) inline_ref {
  int config_index = 21 + workchain;
  var cs = config_param(config_index).begin_parse();
  if (cs.preload_uint(8) == 0xd1) { ;; gas_flat_pfx
    cs~skip_bits(8 + 64 + 64);
  }
  int tag = cs~load_uint(8);
  throw_unless(71, (tag == 0xdd) | (tag == 0xde)); ;; gas_prices or gas_prices_ext
  int gas_price = cs~load_uint(64);
  return (gas * gas_price) >> 16;
}

int msg_fwd_price(int workchain, int cells, int bits) inline_ref {
  int config_index = 25 + workchain;
  var cs = config_param(config_index).begin_parse();
  int tag = cs~load_uint(8);
  throw_unless(71, tag == 0xea); 
  int lump_price = cs~load_uint(64);
  int bit_price = cs~load_uint(64);
  int cell_price = cs~load_uint(64);
  return lump_price + ( (cells * cell_price + bits * bit_price) >> 16);
}

slice pack_addr(int wc, int addr) inline {
  return begin_cell().store_int(wc, 8).store_uint(addr, 256).end_cell().begin_parse();
}

;; =============== DEX helpers =============================

int get_amount_out(int amountIn, int reserveIn, int reserveOut) method_id {
  int amountInWithFee = amountIn * 997;
  int numerator =  amountInWithFee * reserveOut;
  int denominator = reserveIn * 1000 + amountInWithFee;
  return numerator / denominator;
}

;; =============== Dictionary helpers =============================

int _get_balance(cell balances, slice address) {
  (slice balance_slice, int found) = balances.dict_get?(264, address);
  if (found) {
      int val = balance_slice~load_grams(); 
      
    return val;
  } else {
    return 0;
  }
}

(cell, ()) ~set_balance(cell balances, slice address, int value)  {
  
  throw_if(100, value < 0);  ;; Explicit error code
  if(value > 0) {
    balances~dict_set_builder(264, address, begin_cell().store_grams(value));
  } else {
    balances~dict_delete?(264, address);
  }
  return (balances, ());
}


int _get_allowance(cell allowances, slice owner, slice spender) inline {
  (slice owner_slice, int owner_found) = allowances.dict_get?(264, owner);
  if (owner_found) {
    cell dict = owner_slice~load_dict();
    (slice spender_slice, int spender_found) = dict.dict_get?(264, spender);
    if (spender_found) {
      return spender_slice~load_grams();
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

(cell, (int)) ~set_allowance(cell allowances, slice owner, slice spender, int value) {
  (slice owner_slice, int owner_found) = allowances.dict_get?(264, owner);

  cell user_allowances = owner_found ? owner_slice~load_dict() : new_dict();
  if(value) {
    user_allowances~dict_set_builder(264, spender, begin_cell().store_grams(value));
  } else {
    user_allowances~dict_delete?(264, spender);
  }
  if (user_allowances.cell_null?()) {
    allowances~dict_delete?(264, owner);
  } else {
    allowances~dict_set_builder(264, owner, begin_cell().store_dict(user_allowances));
  }

  return (allowances, (~ owner_found));
}

(cell, int) ~change_allowance(cell allowances, slice sender, slice spender, int delta_value, int exact?) impure {
  int old_allowances = _get_allowance(allowances, sender, spender);
  int new_allowances = old_allowances + delta_value;
  if ~ exact? {
    new_allowances = max(new_allowances, 0);
  }
  throw_unless(103, new_allowances >= 0);

  int new_map_fee = - cell_storage_fee() * allowances~set_allowance(sender, spender, new_allowances);

  return (allowances, (old_allowances ? 0 : cell_storage_fee()) + new_map_fee );
}


(int, int) _get_liquidity(cell liquidity, slice address) {
  (slice liquidity_slice, int found) = liquidity.dict_get?(264, address);
  if (found) {
    int amount =  liquidity_slice~load_grams();
    int timestamp =  liquidity_slice~load_uint(32);
    return(amount, timestamp);
  } else {
    return (0, 0);
  }
}

(cell, ()) ~set_liquidity(cell liquidity, slice address, int value) {
  liquidity~dict_set_builder(264, address, begin_cell().store_grams(value).store_uint(now_x, 32));
  return (liquidity, ());
}


;; value - MUST BE NON-NEGATIVE
(cell, (int)) ~transfer(cell balances, slice from, slice to, int value) impure {
  int old_to_balance = _get_balance(balances, to);
  int new_from_balance = _get_balance(balances, from) - value; 
  balances~set_balance(from, new_from_balance );
  balances~set_balance(to, old_to_balance + value);

  return (balances, old_to_balance ? 0 : ( new_from_balance ? cell_storage_fee() : 0 ));
}

(cell, int) ~increase_allowance(cell allowances, slice sender, slice spender, int delta_value) impure {
  int old_allowances = _get_allowance(allowances, sender, spender);
  int new_allowances = old_allowances + delta_value;
  throw_unless(103, new_allowances >= 0);
  allowances~set_allowance(sender, spender, new_allowances);
  return (allowances, new_allowances);
}

slice clone_slice(slice s) {
  return begin_cell().store_slice(s).end_cell().begin_parse();
}

;; sender - raw address
() bounce_back(slice sender, int action, int query_id, int query_action) impure {
  ;; int_msg_info ihr_disabled:1 bounce:1 bounced:0 src:MsgAddress -> 011000
  var msg = begin_cell()
      .store_uint(0x10, 6)
      .store_slice(sender)
      .store_grams(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(action, 32)
      .store_uint(query_id, 64)
      .store_uint(query_action, 32);

  send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message
}


;; ======= Memory Methods =================

(slice, slice, int, int, int, int, int, cell, cell, cell, int) load_data(cell data) {
  slice ds = data.begin_parse();
  int name_size = ds~load_uint(8);
  slice name = ds~load_bits(name_size * 8);
  int symbol_size = ds~load_uint(8);
  slice symbol = ds~load_bits(symbol_size * 8);
  int decimals = ds~load_uint(8);
  int total_supply = ds~load_grams();
  int total_lp_supply = ds~load_grams();
  int token_reserves = ds~load_grams();
  int ton_reserves = ds~load_grams();
  cell balances = ds~load_dict();
  cell approvals = ds~load_dict();
  cell liquidity = ds~load_dict();
  int initialised = ds~load_uint(1);
  var result = (name, symbol, decimals, total_supply, total_lp_supply, token_reserves, ton_reserves, balances, approvals, liquidity, initialised);
  ds.end_parse();
  return result;
}

() store_data(slice name, slice symbol, int decimals, int total_supply, total_lp_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, cell liquidity, int initialized) impure {
  
  set_data(begin_cell()
    .store_uint(name.slice_bits() / 8, 8)
    .store_slice(name)
    .store_uint(symbol.slice_bits() / 8, 8)
    .store_slice(symbol)
    .store_uint(decimals, 8)
    .store_grams(total_supply)
    .store_grams(total_lp_supply)
    .store_grams(token_reserves)
    .store_grams(ton_reserves)
    .store_dict(balances)
    .store_dict(allowances)
    .store_dict(liquidity)
    .store_uint(initialized, 1)
    .end_cell()
  );
}


;; =============  Using babylonian method for Math.sqrt
int squareRoot(int number)  {
    if(number < 3) {
      return 1;
    }
    int lo = 0;
    int hi = number;
    while( lo <= hi ) {
         var mid = (lo + hi) / 2;
         if( mid * mid > number) {
           hi = mid - 1;
         } else {
           lo = mid + 1;
         } 
    }
    return hi;
}

() send_grams(slice address, int amount) impure {
	;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    cell msg = begin_cell()
    ;;	.store_uint(0, 1) ;; 0 <= format indicator int_msg_info$0 
    ;;	.store_uint(1, 1) ;; 1 <= ihr disabled
    ;;	.store_uint(1, 1) ;; 1 <= bounce = true
    ;;	.store_uint(0, 1) ;; 0 <= bounced = false
    ;;	.store_uint(4, 5)  ;; 00100 <= address flags, anycast = false, 8-bit workchain
        .store_uint (196, 9)
        .store_slice(address)
        .store_grams(amount)
        .store_uint(0, 107) ;; 106 zeroes +  0 as an indicator that there is no cell with the data.
        .end_cell(); 
    send_raw_message(msg, 3); ;; mode, 2 for ignoring errors, 1 for sender pays fees, 64 for returning inbound message value
}

;; ============= Dex Functions =============================

(int) swapTokens (int min_amount_out, int transferd_amount, int is_ton_src, slice sender) impure {
    int storage_fee = 0;
  
    (slice name, slice symbol, int decimals, int total_supply, int total_lp_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, cell liquidity, int initialized) = load_data(get_data());
    
    int src_resvers = is_ton_src == true ? ton_reserves : token_reserves;
    int trgt_resvers = is_ton_src == true ? token_reserves : ton_reserves;  
    int amount_out = get_amount_out( transferd_amount, src_resvers, trgt_resvers);
    throw_if(601, amount_out < min_amount_out);

  
    if(is_ton_src == true) {
      ton_reserves = src_resvers + transferd_amount;
      token_reserves = trgt_resvers - amount_out;
      storage_fee += balances~transfer(my_address_x, sender, amount_out);
      ;; TODO SEND RECIPT
    } else {
      ton_reserves = trgt_resvers - amount_out;
      token_reserves = src_resvers + transferd_amount;
      send_grams(sender, amount_out);
    }
    
    store_data(name, symbol, decimals, total_supply, total_lp_supply, token_reserves, ton_reserves, balances, allowances, liquidity, initialized);
    return amount_out;
}


() send_transfer_from(slice from_addr, slice to_addr, int amount, slice currency_address, int order_id) {

    builder msg = begin_cell()
      .store_uint(0x18, 6)
      .store_uint(0x4, 3)
      .store_slice(currency_address)
      .store_grams(1)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(2, 32) ;; transfer action
      .store_uint(order_id, 64)
      .store_slice(from_addr)
      .store_slice(to_addr)
      .store_grams(amount);

    send_raw_message(msg.end_cell(), 0);
}


(cell, cell, int, int, int, int, int) _burn_liquidity(cell balances, cell liquidity, slice sender, int lp_amount_to_remove, int total_lp_supply, int ton_reserves,int token_reserves) impure {
    int storage_fee = 0;
    
    int shareInLp = total_lp_supply / lp_amount_to_remove;
    int share_in_ton_reserves = (lp_amount_to_remove * ton_reserves) / total_lp_supply;
    int share_in_token_reserves = (lp_amount_to_remove * token_reserves) / total_lp_supply;

    ;; TODO ========================================================
    ;; slice conract_address = my_address();
    slice conract_address = my_address_x;
    int contracts_balance = _get_balance(balances, my_address_x);
    ;; TODO ========================================================

    int current_balance = _get_balance(balances, sender);
    storage_fee += balances~transfer(conract_address, sender, share_in_token_reserves);
    int user_liquidity = _get_balance(liquidity, sender);

    ;; i think no gas is consumed
    int lq = user_liquidity - lp_amount_to_remove;
    liquidity~set_balance(sender, user_liquidity - lp_amount_to_remove);

    send_grams(sender, share_in_ton_reserves);
    return ( balances, liquidity, storage_fee, total_lp_supply, token_reserves, ton_reserves, share_in_ton_reserves);
}

(cell, int) ~claim_rewards(cell liquidity, slice address, int reward_rate, int total_lp_supply, int token_reserves) {

  (slice liquidity_slice, int found) = liquidity.dict_get?(264, address);
  if (found) {
    
    int lp_amount =  liquidity_slice~load_grams();
    int user_tokens = (lp_amount / total_lp_supply) * token_reserves;
    int timestamp =  liquidity_slice~load_uint(32);
    int minutes_staked =  (now_x - timestamp);
    int rewards = user_tokens * minutes_staked * reward_rate;
    liquidity~dict_set_builder(264, address, begin_cell().store_grams(lp_amount).store_uint(now_x, 32));
    return (liquidity, rewards);
  } 
  return (liquidity, 0);
}

(cell, int, int, int, int) mint_lp_token(cell balances, cell liquidity, slice sender, int price, int ton_amount, int token_amount, int token_reserves, int ton_reserves, int total_lp_supply) impure {
    int x = 122;
    int y = 222;
    int z = 322;
    
    int new_liquidity = 0;
    int storage_fee = 0;
    int MINIMUM_LIQUIDITY = 1; ;; TODO IT SHOULD BE 1000

    ;; TODO fix handle liquidtiy supply on its own param
    if( token_reserves == 0  ) {
      ;; calc the user share  Sushi (Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);)
      new_liquidity = squareRoot(ton_amount * token_amount) / MINIMUM_LIQUIDITY;
    } else {
      ;; liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
      int ton_share = (ton_amount * total_lp_supply) / ton_reserves;
      int token_share = (token_amount * total_lp_supply) / token_reserves;
      new_liquidity = min(ton_share, token_share);
    }
    
    ;; TODO ========================================================
    ;; slice conract_address = my_address();
    
    ~dump x;
    ~dump token_amount;
    ~dump ton_amount;
    ~dump x;
    
    int contracts_balance = _get_balance(balances, my_address_x);
    
    ;; TODO ========================================================
    ~dump y;
    ~dump token_reserves;
    ~dump ton_reserves;
    ~dump y;

    storage_fee += balances~transfer(sender, my_address_x, token_amount);
    token_reserves = token_amount + token_reserves;
    ton_reserves = ton_amount + ton_reserves;
    
    ~dump z;
    ~dump token_reserves;
    ~dump ton_reserves;
    ~dump z;

    total_lp_supply = new_liquidity + total_lp_supply;

    int old_senders_liquidity = _get_balance(liquidity, sender);
    ;; setting the new liquidity to the user
    
    liquidity~set_liquidity(sender, new_liquidity + old_senders_liquidity);
    

    if ( old_senders_liquidity > 0 ) {
      storage_fee += cell_storage_fee();
    }
    int after_set = _get_balance(liquidity, sender);
    return (liquidity, total_lp_supply, token_reserves, ton_reserves, storage_fee);
    ;; Should send callback or set the state for the callback to be completed 
 }


;; to_addr - 264bit address
;; address - 264bit address
() send_receipt(slice to_addr,
                int action, int query_id,
                slice address,
                int sign, int value,
                int reserve,
                builder payload) impure {
  ;; int_msg_info ihr_disabled:1 bounce:1 bounced:0 src:MsgAddress -> 011000
  var msg = begin_cell()
      .store_uint(0x10, 6)
      .store_uint(0x4, 3)
      .store_slice(to_addr)
      .store_grams(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(action, 32)
      .store_uint(query_id, 64)
      .store_slice(address)
      .store_grams(value);

  if (payload.builder_bits() + msg.builder_bits() > 1023) {
    msg = msg.store_builder_ref(payload);
  } else {
    msg = msg.store_builder(payload);
  }
  if reserve {
    raw_reserve(reserve, 0);
  }
  send_raw_message(msg.end_cell(), 128);
}


(int) recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; (int chain_id, _) = parse_std_addr(my_address());
    ;; TODO testing 

    
    int chain_id = 0;
    
    slice cs = in_msg_cell.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore bounces
      return (0);
    }
    slice sender_raw = cs~load_msg_addr();
    (int sender_wc, int sender_addr) = parse_std_addr(sender_raw);
    slice sender = pack_addr(sender_wc, sender_addr);
    
    ;; TODO 
    slice my_f_address = pack_addr(-1, sender_addr);
    my_address_x = my_f_address;
    now_x = 1644329284;
    
    cs = in_msg;
    if (cs.slice_bits() == 0) { ;; just accept grams
        return (0);
    }

    int action = cs~load_uint(32);
    int query_id = cs~load_uint(64);
    ;; TODO support gas limit as an input paramter
    ;; int gas_limit = cs~load_grams();
    ;; set_gas_limit(gas_limit);
    

    ;; if (action > 9) {
    ;;  bounce_back(sender_raw, 0xffffffff, query_id, action); ;; operation not supported
    ;;  return ();
    ;; }

    (slice name, slice symbol, int decimals, int total_supply, int total_lp_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, cell liquidity, int initialized) = load_data(get_data());
    slice to = null();
    int value = 0;
    int sign = 0;
    int storage_fee = 0;
    int return_value = 0;

    if(action == 101) {
      balances~set_balance(my_address_x, 100000000000000);
      balances~set_balance(sender, 200000000000000);
      allowances = new_dict();
      liquidity = new_dict();
      store_data(name, symbol, decimals, total_supply, total_lp_supply, token_reserves, ton_reserves, balances, allowances, liquidity, initialized);
      return action;
    }

    ;;  < amount_a Gram, amount_b Gram, token_address_a uint256, token_address_b uint256 ,slipage int32, b>  
    if (action == 1) { ;; transfer
      to = cs~load_bits(264);
      value = cs~load_grams();
      storage_fee += balances~transfer(sender, to, value);
      return_value = 1;
    } elseif (action == 2) { ;; transfer_from

      slice from = cs~load_bits(264);
      to = cs~load_bits(264);
      value = cs~load_grams();

      storage_fee += allowances~change_allowance(from, sender, - value, 1);
      storage_fee += balances~transfer(from, to, value);
      return_value = 2;
    } elseif (action == 3) { ;; increase/decrease allowance

      sign = cs~load_uint(1);
      slice spender = cs~load_bits(264);
      to = spender;
      int delta_value = cs~load_grams();
      int exact = cs~load_uint(1);

      storage_fee += allowances~change_allowance(sender, spender, sign ? - delta_value : delta_value, exact);
      return_value = 3;
    } elseif (action == 4) { ;; claim rewards
      ;; TODO add reward_rate is a memroy parm 
      int rewards = liquidity~claim_rewards(sender, 10, total_lp_supply, token_reserves);
      int sender_balance = _get_balance(balances, sender);
      balances~set_balance(sender, rewards + sender_balance);
      return_value = 4;
    }  elseif (action == 5) { ;; add liquidity
        
        int token_new_liquidity = cs~load_grams();
        int slipage = cs~load_uint(64);
        
        throw_if(98, 0 >= token_new_liquidity);
        throw_if(99, 0 >= msg_value);

        int msg_price = token_new_liquidity / msg_value;
        
        ;; check slipage only for the first time
        int reserves_price = 0;
        int price_delta = 0;
        
        ~dump action;
          ~dump token_reserves;
            ~dump ton_reserves;
        
        if ( token_reserves > 0 ) {
          
          reserves_price = token_reserves / ton_reserves ;
          ~dump action;
          ~dump action;
          ~dump reserves_price;
          ~dump msg_price;
          price_delta =  ( ( msg_price / reserves_price ) - 1 ) * 100;
          throw_if(103,  price_delta > slipage );
        }

        (liquidity, total_lp_supply, token_reserves, ton_reserves, int fee) = mint_lp_token(balances, liquidity, sender, reserves_price, msg_value, token_new_liquidity, token_reserves, ton_reserves, total_lp_supply);
~dump action;
        (int newliq, _) = _get_liquidity(liquidity, sender);
        return_value = newliq;
        ~dump newliq;
       ;; store_data(name, symbol, decimals, total_supply, new_lp_supply, new_token_reserves, new_ton_reserves, balances, allowances, new_liquidity, initialized);
        
        storage_fee += fee;
    } elseif (action == 6 ) { ;; Remove liquidty
        
        ;; lp value
        int lp_amount_to_remove = cs~load_grams();
        int user_lp_balance = _get_balance(liquidity, sender);
        throw_if( 104, user_lp_balance < lp_amount_to_remove);

        (balances, liquidity, int fee, total_lp_supply, token_reserves, ton_reserves, int users_new_ton) = _burn_liquidity(balances, liquidity, sender, lp_amount_to_remove, total_lp_supply, token_reserves, ton_reserves);
        storage_fee += fee;
        return_value = users_new_ton;
    } elseif ( action == 7 ) {
        ;; <b 10TON , min_amount_out=99 b>
        int min_amount_out = cs~load_grams();
        return_value = swapTokens(min_amount_out, msg_value, true, sender);

    } elseif( action == 8 ) {
          ;; <b  killo 100 , min_amount_out=10 b>
          int transferd_amount = cs~load_grams();
          int senders_balance = _get_balance(balances, sender);
          throw_if( 102, senders_balance < transferd_amount);
          int min_amount_out = cs~load_grams(); 
          
          return_value = swapTokens(min_amount_out, msg_value, false, sender);
      }        


    
    store_data(name, symbol, decimals, total_supply, total_lp_supply, token_reserves, ton_reserves, balances, allowances, liquidity, initialized);
    ;; ensure that receipt carries at least 10k gas
    (int cells, int bits, int refs) = cs.slice_compute_data_size(10);
    ;; msg value has enough coins to pay for 
    ;;  1) storing cells created during tx plus
    ;;  2) this tx gas costs
    ;;  3) 10k gas for processing of outcoming message
    ;;  4) forward fee for outcoming message
    
    ;;throw_unless(111, msg_value > storage_fee + gas_to_coins(chain_id, gas_limit + 10000) + msg_fwd_price(cells, bits, chain_id));
    
    
    
    return return_value;
}

() recv_external(slice in_msg) impure {
  ;;nop
}

;; Returns the account balance of another account with address _owner.
(int, int) liquidity_of(int owner_wc, int owner_addr) method_id {
  slice owner = begin_cell().store_int(owner_wc, 8).store_uint(owner_addr, 256).end_cell().begin_parse();
  
  (_, _, _, _, _, _, _, _, _, cell liquidity, int initialized) = load_data(get_data());
  (int a, int ts) = _get_liquidity(liquidity, owner);
  ~dump a;
  ~dump ts;
  return _get_liquidity(liquidity, owner);
}



;;======================================================================
;;======================== TRC20  ================================
;;======================================================================


;; Returns the name of the token.
(slice, slice, int, int, int, int, int) get_token_data() method_id {
  (slice name, slice symbol, int decimals, int total_supply, int total_lp_supply, int token_reserves, int ton_reserves, _, _, _, _) = load_data(get_data());
  return (name, symbol, decimals, total_supply, total_lp_supply, token_reserves, ton_reserves);
}

;; Returns the account balance of another account with address _owner.
int balance_of(slice owner) method_id {
  (_, _, _, _, _, _, _, cell balances, _, _, _) = load_data(get_data());
  return _get_balance(balances, owner);
}

int allowance(slice owner, slice spender) method_id {
  (slice name, slice symbol, int decimals, int total_supply, int total_lp_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, cell liquidity, int initialized) = load_data(get_data());

  return _get_allowance(allowances, owner, spender);
}

;; I dont know how to pass more than two paramters to read function
var get_amount_out_lp(int amountIn, int is_token_src) method_id {
  (slice name, slice symbol, int decimals, int total_supply, int total_lp_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, cell liquidity, int initialized) = load_data(get_data());
  int amountInWithFee = amountIn * 997;
  int reserveIn = is_token_src ? token_reserves : ton_reserves;
  int reserveOut = is_token_src ? ton_reserves : token_reserves;
  
  int numerator =  amountInWithFee * reserveOut;
  int denominator = reserveIn * 1000 + amountInWithFee;
  return numerator / denominator;

}

;;======================================================================
;;======================== Test Methods ================================
;;======================================================================

int ibalance_of(int owner_wc, int owner_addr) method_id {
  slice owner = begin_cell().store_int(owner_wc, 8).store_uint(owner_addr, 256).end_cell().begin_parse();
  return balance_of(owner);
}

int iallowance(int owner_wc, int owner_addr, int spender_wc, int spender_addr) method_id {
  slice owner = begin_cell().store_int(owner_wc, 8).store_uint(owner_addr, 256).end_cell().begin_parse();
  slice spender = begin_cell().store_int(spender_wc, 8).store_uint(spender_addr, 256).end_cell().begin_parse();
  return allowance(owner, spender);
}

int test_recv_external(slice in_msg) method_id {
  recv_external(in_msg);
  return 0;
}

int test_recv_internal(int value, cell in_msg_cell, slice in_msg) method_id {
  
  ;; =========== Testing Purposes Only !!!! ================== ;
  slice cs = in_msg_cell.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) { ;; ignore bounces
      return (0);
  }
  slice sender_raw = cs~load_msg_addr();

  (int sender_wc, int sender_addr) = parse_std_addr(sender_raw);
  slice sender = pack_addr(sender_wc, sender_addr);
  slice my_f_address = pack_addr(-1, sender_addr);
  my_address_x = my_f_address;
  now_x = 1644329284;

  (slice name, slice symbol, int decimals, int total_supply, int total_lp_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, cell liquidity, int initialized) = load_data(get_data());
  balances~set_balance(my_address_x, 100000000000000);
  balances~set_balance(sender, 200000000000000);
  store_data(name, symbol, decimals, total_supply, total_lp_supply, token_reserves, ton_reserves, balances, allowances, liquidity, initialized);
  return recv_internal(value, in_msg_cell, in_msg);
}