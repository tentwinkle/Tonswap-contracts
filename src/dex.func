;; AMM & LP combined
;; storage : {
;;   slice name,
;;   slice symbol,
;;   uint8 decimals,
;;   cell token_address,
;;   cell token_rewards_admin,           [this role can set token_alloc_points]
;;   uint32 token_alloc_points, 
;;   cell protcol_rewards_admin, [this role can set protocl_alloc_points] 
;;   uint32 protocol_alloc_points,
;;   uint256 total_supply,
;;   grams token_reserves,
;;   grams ton_reserves,
;;   balances : {
;;     slice address : uint256 amount
;;   },
;;   approvals : {
;;     slice sender : {
;;       slice spender: uint256 amount
;;     }
;;   }
;;   uint8 initialised 
;;}

;; ============= actions ====================
;; transfer = 1 TRC20 
;; transfer_from = 2 TRC20 
;; increase/decrease = 3 TRC20
int op::claim_rewards() asm "4 PUSHINT";
int op::add_liquidity() asm "2 PUSHINT";  ;; sub op of trc20:transfer
int op::remove_liquidity() asm "6 PUSHINT";
int op::swap_in() asm "7 PUSHINT";        ;; sub op of trc20:transfer
int op::swap_out() asm "8 PUSHINT";
int op::update_token_data() asm "9 PUSHINT";
int op::update_protocol_data() asm "10 PUSHINT";
int op::transfer_recipt() asm "536870913 PUSHINT";
int op::transfer_from_recipt() asm "536870914 PUSHINT";

int erorr::trc20_insufficent_transfer()  asm "1000 PUSHINT";
int erorr::trc20_bad_source_address()    asm "0x40001 PUSHINT";
int erorr::update_token_no_role()        asm "0x40002 PUSHINT";
int erorr::update_admin_no_role()        asm "0x40003 PUSHINT";

int equal_slices (slice s1, slice s2) asm "SDEQ";
builder store_builder(builder to, builder what) asm(what to) "STB";
builder store_builder_ref(builder to, builder what) asm(what to) "STBREFR";
(cell, int) dict_delete?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDEL";
(slice, int) dict_get?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTGET" "NULLSWAPIFNOT";



;; =============== GAS Functions =============================

int cell_storage_fee() asm "10000000 PUSHINT"; ;; 0.01 TON
int gas_to_coins(int workchain, int gas) inline_ref {
  int config_index = 21 + workchain;
  var cs = config_param(config_index).begin_parse();
  if (cs.preload_uint(8) == 0xd1) { ;; gas_flat_pfx
    cs~skip_bits(8 + 64 + 64);
  }
  int tag = cs~load_uint(8);
  throw_unless(71, (tag == 0xdd) | (tag == 0xde)); ;; gas_prices or gas_prices_ext
  int gas_price = cs~load_uint(64);
  return (gas * gas_price) >> 16;
}

int msg_fwd_price(int workchain, int cells, int bits) inline_ref {
  int config_index = 25 + workchain;
  var cs = config_param(config_index).begin_parse();
  int tag = cs~load_uint(8);
  throw_unless(71, tag == 0xea); 
  int lump_price = cs~load_uint(64);
  int bit_price = cs~load_uint(64);
  int cell_price = cs~load_uint(64);
  return lump_price + ( (cells * cell_price + bits * bit_price) >> 16);
}

slice pack_addr(int wc, int addr) inline {
  return begin_cell().store_int(wc, 8).store_uint(addr, 256).end_cell().begin_parse();
}

;; =============== DEX helpers =============================

int get_amount_out(int amountIn, int reserveIn, int reserveOut) method_id {
  int amountInWithFee = amountIn * 997; ;; lp fees 0.3% 
  int numerator =  amountInWithFee * reserveOut;
  int denominator = reserveIn * 1000 + amountInWithFee;
  return numerator / denominator;
}

;; =============== Dictionary helpers =============================

int _get_balance(cell balances, slice address) {
  (slice balance_slice, int found) = balances.dict_get?(264, address);
  if (found) {
      ;; TODO GET TIME STAMP
      int val = balance_slice~load_grams(); 
      
    return val;
  } else {
    return 0;
  }
}

(cell, ()) ~set_balance(cell balances, slice address, int value)  {
   throw_if(erorr::trc20_insufficent_transfer(), value < 0);  ;; Explicit error code
  if(value > 0) {
    balances~dict_set_builder(264, address, begin_cell().store_grams(value).store_uint(now(), 64));
  } else {
    balances~dict_delete?(264, address);
  }
  return (balances, ());
}


int _get_allowance(cell allowances, slice owner, slice spender) inline {
  (slice owner_slice, int owner_found) = allowances.dict_get?(264, owner);
  if (owner_found) {
    cell dict = owner_slice~load_dict();
    (slice spender_slice, int spender_found) = dict.dict_get?(264, spender);
    if (spender_found) {
      return spender_slice~load_grams();
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

(cell, (int)) ~set_allowance(cell allowances, slice owner, slice spender, int value) {
  (slice owner_slice, int owner_found) = allowances.dict_get?(264, owner);

  cell user_allowances = owner_found ? owner_slice~load_dict() : new_dict();
  if(value) {
    user_allowances~dict_set_builder(264, spender, begin_cell().store_grams(value));
  } else {
    user_allowances~dict_delete?(264, spender);
  }
  if (user_allowances.cell_null?()) {
    allowances~dict_delete?(264, owner);
  } else {
    allowances~dict_set_builder(264, owner, begin_cell().store_dict(user_allowances));
  }

  return (allowances, (~ owner_found));
}

(cell, int) ~change_allowance(cell allowances, slice sender, slice spender, int delta_value, int exact?) impure {
  int old_allowances = _get_allowance(allowances, sender, spender);
  int new_allowances = old_allowances + delta_value;
  if ~ exact? {
    new_allowances = max(new_allowances, 0);
  }
  throw_unless(103, new_allowances >= 0);

  int new_map_fee = - cell_storage_fee() * allowances~set_allowance(sender, spender, new_allowances);

  return (allowances, (old_allowances ? 0 : cell_storage_fee()) + new_map_fee );
}


() send_token_to(slice token_address, slice to, int token_amount, int query_id) impure {
   ;; TODO reserve gas for messaage
    if token_amount == 0 {
      return ();
    }
    (int wc, int addr) = parse_std_addr(token_address);
    slice token_packed = pack_addr(wc, addr);


    int fee = 100000000; ;; 0.1TON for send message , should assert
    builder msg = begin_cell()
         .store_uint(0x18, 6)
         .store_uint(0x4, 3)
         .store_slice(token_packed)
         .store_grams(fee)
         .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
         .store_uint(1, 32) ;; transfer action
         .store_uint(query_id, 64)
         .store_slice(to)
         .store_grams(token_amount);

   ;;raw_reserve(msg_cost, 0);
   send_raw_message(msg.end_cell(), 2);

}

;; value - MUST BE NON-NEGATIVE
(cell, (int)) ~transfer(cell balances, slice from, slice to, int value) impure {
  int old_to_balance = _get_balance(balances, to);
  int new_from_balance = _get_balance(balances, from) - value;

  ;;when moving lp-tokens we must claim rewards before the transfer ,  
  balances~set_balance(from, new_from_balance );
  balances~set_balance(to, old_to_balance + value);

  return (balances, old_to_balance ? 0 : ( new_from_balance ? cell_storage_fee() : 0 ));
}

(cell, int) ~increase_allowance(cell allowances, slice sender, slice spender, int delta_value) impure {
  int old_allowances = _get_allowance(allowances, sender, spender);
  int new_allowances = old_allowances + delta_value;
  throw_unless(103, new_allowances >= 0);
  allowances~set_allowance(sender, spender, new_allowances);
  return (allowances, new_allowances);
}

;; sender - raw address
() bounce_back(slice sender, int action, int query_id, int query_action) impure {
  ;; int_msg_info ihr_disabled:1 bounce:1 bounced:0 src:MsgAddress -> 011000
  var msg = begin_cell()
      .store_uint(0x10, 6)
      .store_slice(sender)
      .store_grams(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(action, 32)
      .store_uint(query_id, 64)
      .store_uint(query_action, 32);

  send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message
}


;; ======= Memory Methods =================

_ load_data(cell data) {
  slice ds = data.begin_parse();
  int name_size = ds~load_uint(8);
  slice name = ds~load_bits(name_size * 8);
  int symbol_size = ds~load_uint(8);
  slice symbol = ds~load_bits(symbol_size * 8);
  int decimals = ds~load_uint(8);
  int total_supply = ds~load_grams();
  int token_reserves = ds~load_grams();
  int ton_reserves = ds~load_grams();
  cell balances = ds~load_dict();
  cell approvals = ds~load_dict();
  slice token_address = ds~load_msg_addr();
  
  int initialised = ds~load_uint(1);
  
  slice ds2 = ds~load_ref().begin_parse();
  slice token_rewards_admin = ds2~load_msg_addr();
  int token_alloc_points = ds2~load_grams();
  slice protocol_rewards_admin = ds2~load_msg_addr();
  int protocol_alloc_points = ds2~load_grams();

  var result = (
    name,
    symbol,
    decimals,
    total_supply,
    token_reserves,
    ton_reserves,
    balances,
    approvals,
    token_address,
    initialised,
    token_rewards_admin,
    token_alloc_points,
    protocol_rewards_admin,
    protocol_alloc_points
  );
  ds2.end_parse();
  ds.end_parse();
  return result;
}


() store_data(slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, slice token_rewards_admin, int token_alloc_points, slice protocol_rewards_admin, int protocol_alloc_points) impure {
  
  cell admin_data =  begin_cell().store_slice(token_rewards_admin)
  .store_grams(token_alloc_points)
  .store_slice(protocol_rewards_admin)
  .store_grams(protocol_alloc_points).end_cell();

  cell data = begin_cell()
    .store_uint(name.slice_bits() / 8, 8)
    .store_slice(name)
    .store_uint(symbol.slice_bits() / 8, 8)
    .store_slice(symbol)
    .store_uint(decimals, 8)
    .store_grams(total_supply)
    .store_grams(token_reserves)
    .store_grams(ton_reserves)
    .store_dict(balances)
    .store_dict(allowances)
    .store_slice(token_address)
    .store_uint(initialized, 1)
    .store_ref(admin_data)
    .end_cell();

  set_data(data);
}


;; =============  Using babylonian method for Math.sqrt
int squareRoot(int number)  {
    if(number < 3) {
      return 1;
    }
    int lo = 0;
    int hi = number;
    while( lo <= hi ) {
         var mid = (lo + hi) / 2;
         if( mid * mid > number) {
           hi = mid - 1;
         } else {
           lo = mid + 1;
         } 
    }
    return hi;
}

() send_grams(slice address, int amount) impure {

    int msg_cost = 100000;
    builder msg = begin_cell()
          .store_uint(0xc4, 9)
          .store_slice(address) ;; 264 bit address
          .store_grams(amount - msg_cost)
          .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);


    raw_reserve(msg_cost, 0);
    send_raw_message(msg.end_cell(), 64);
}

;; ============= Dex Functions =============================
;; sender : address264
(int) swapTokens (int min_amount_out, int transferd_amount, int is_ton_src, slice sender) impure {
    int storage_fee = 0;

    (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, slice token_rewards_admin,int token_alloc_points ,slice protocol_rewards_admin ,int protocol_alloc_points) = load_data(get_data());

    int src_resvers = is_ton_src == true ? ton_reserves : token_reserves;
    int trgt_resvers = is_ton_src == true ? token_reserves : ton_reserves;
    int amount_out = get_amount_out( transferd_amount, src_resvers, trgt_resvers);
    throw_if(601, amount_out < min_amount_out);

    if(is_ton_src == true) {
      ton_reserves = src_resvers + transferd_amount;
      token_reserves = trgt_resvers - amount_out;
      store_data(name, symbol, decimals, total_supply, token_reserves, ton_reserves, balances, allowances, token_address, initialized, token_rewards_admin, token_alloc_points, protocol_rewards_admin, protocol_alloc_points);
      send_token_to(token_address, sender, amount_out, 1);
      ;; TODO think of query ID purpose
      ;; TODO SEND RECIPT
    } else {
      ton_reserves = trgt_resvers - amount_out;
      token_reserves = src_resvers + transferd_amount;
      store_data(name, symbol, decimals, total_supply, token_reserves, ton_reserves, balances, allowances, token_address, initialized, token_rewards_admin, token_alloc_points, protocol_rewards_admin, protocol_alloc_points);
      send_grams(sender, amount_out);
    }
    return amount_out;
}


() send_transfer_from(slice from_addr, slice to_addr, int amount, slice currency_address, int order_id) {

    builder msg = begin_cell()
      .store_uint(0x18, 6)
      .store_uint(0x4, 3)
      .store_slice(currency_address)
      .store_grams(1)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(2, 32) ;; transfer action
      .store_uint(order_id, 64)
      .store_slice(from_addr)
      .store_slice(to_addr)
      .store_grams(amount);

    send_raw_message(msg.end_cell(), 0);
}


(cell, int, int, int, int, int) _burn_liquidity(cell balances, slice sender, int amount_to_remove, int total_supply, int ton_reserves ,int token_reserves, slice token_address, int query_id) impure {
    int storage_fee = 0;
    int share_on_lp = total_supply / amount_to_remove;
    int share_in_ton_reserves = (amount_to_remove * ton_reserves) / total_supply;
    int share_in_token_reserves = (amount_to_remove * token_reserves) / total_supply;

    int current_balance = _get_balance(balances, sender);
    int user_liquidity = _get_balance(balances, sender);
    int lq = user_liquidity - amount_to_remove;
    balances~set_balance(sender, user_liquidity - amount_to_remove);

    send_token_to(token_address, sender, share_in_token_reserves, query_id);
    send_grams(sender, share_in_ton_reserves);

    return ( balances, storage_fee, total_supply, token_reserves, ton_reserves, share_in_ton_reserves);
}

(int) calc_rewards_seconds(int seconds_staked, int reward_rate, int lp_amount, int token_reserves, int total_supply) {
  int daily_rewards =  muldiv(token_reserves, reward_rate, 100000000);
  int reward_per_second = daily_rewards / (3600 * 24);
  int period_rewards = reward_per_second * seconds_staked;
  return (period_rewards * lp_amount) / total_supply;
}

(int, int) calc_rewards(slice liquidity_slice, int total_supply, int token_reserves, int token_reward_rate, int protocol_reward_rate) {
  int lp_amount =  liquidity_slice~load_grams();
  int timestamp =  liquidity_slice~load_uint(64);

  int seconds_staked = (now() - timestamp);
  int token_rewards = calc_rewards_seconds(seconds_staked, token_reward_rate, lp_amount, token_reserves, total_supply);
  int protocol_rewards = calc_rewards_seconds(seconds_staked, protocol_reward_rate, lp_amount, token_reserves, total_supply);
  int rewards = token_rewards + protocol_rewards;
  return ( rewards, lp_amount );
}


(cell, int) ~claim_rewards(cell balances, slice address, int token_reward_rate, int protocol_reward_rate, int total_supply, int token_reserves) {
  (slice liquidity_slice, int found) = balances.dict_get?(264, address);
  if (found) {
    (int user_rewards, int lp_amount) = calc_rewards(liquidity_slice, total_supply, token_reserves, token_reward_rate, protocol_reward_rate);
    balances~dict_set_builder(264, address, begin_cell().store_grams(lp_amount).store_uint(now(), 64));
    return (balances, user_rewards);
  }
  return (balances, 0);
}

(cell, int, int, int, int) mint_lp(cell balances, slice sender, int ton_amount, int token_amount, int token_reserves, int ton_reserves, int total_lp_supply) impure {
    int new_liquidity = 0;
    int storage_fee = 0;
    int MINIMUM_LIQUIDITY = 1; ;; TODO IT SHOULD BE 1000

    ;; TODO fix handle liquidtiy supply on its own param
    if( token_reserves == 0  ) {
      ;; calc the user share  Sushi (Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);)
      new_liquidity = squareRoot(ton_amount * token_amount) / MINIMUM_LIQUIDITY;
    } else {
      ;; liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
      int ton_share = (ton_amount * total_lp_supply) / ton_reserves;
      int token_share = (token_amount * total_lp_supply) / token_reserves;
      new_liquidity = min(ton_share, token_share);
    }

    token_reserves = token_amount + token_reserves;
    ton_reserves = ton_amount + ton_reserves;

    total_lp_supply = new_liquidity + total_lp_supply;
    int old_senders_liquidity = _get_balance(balances, sender);
    balances~set_balance(sender, new_liquidity + old_senders_liquidity);

    if ( old_senders_liquidity == 0 ) {
      storage_fee += cell_storage_fee();
    }
    return (balances, total_lp_supply, token_reserves, ton_reserves, storage_fee);
    ;; Should send callback or set the state for the callback to be completed
 }


;; to_addr - 264bit address
;; address - 264bit address
() send_receipt(slice to_addr,
                int action, int query_id,
                slice address,
                int sign, int value,
                int reserve,
                builder payload) impure {
  ;; int_msg_info ihr_disabled:1 bounce:1 bounced:0 src:MsgAddress -> 011000
  var msg = begin_cell()
      .store_uint(0x10, 6)
      .store_uint(0x4, 3)
      .store_slice(to_addr)
      .store_grams(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(action, 32)
      .store_uint(query_id, 64)
      .store_slice(address)
      .store_grams(value);

  if (payload.builder_bits() + msg.builder_bits() > 1023) {
    msg = msg.store_builder_ref(payload);
  } else {
    msg = msg.store_builder(payload);
  }
  if reserve {
    raw_reserve(reserve, 0);
  }
  send_raw_message(msg.end_cell(), 64);
}

(int) recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; (int chain_id, _) = parse_std_addr(my_address());
    ;; TODO testing


    int chain_id = 0;

    slice cs = in_msg_cell.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore bounces
      return (0);
    }
    slice sender_raw = cs~load_msg_addr();
    (int sender_wc, int sender_addr) = parse_std_addr(sender_raw);
    slice sender = pack_addr(sender_wc, sender_addr);


    cs = in_msg;
    if (cs.slice_bits() == 0) { ;; just accept grams
        return (0);
    }

    int action = cs~load_uint(32);

    (action, cs) = parse_msg(action, cs);

    int query_id = cs~load_uint(64);
    ;; TODO support gas limit as an input paramter
    ;; int gas_limit = cs~load_grams();
    ;; set_gas_limit(gas_limit);


    ;; if (action > 9) {
    ;;  bounce_back(sender_raw, 0xffffffff, query_id, action);
    ;;  return ();
    ;; }
    (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, slice token_rewards_admin, int token_alloc_points, slice protocol_rewards_admin, int protocol_alloc_points) = load_data(get_data());
    slice to = sender;
    int value = 0;
    int sign = 0;
    int storage_fee = 0;
    int return_value = 0;

    if(action == 101) {
      balances = new_dict();
      allowances = new_dict();
      store_data(name, symbol, decimals, total_supply, token_reserves, ton_reserves, balances, allowances, token_address, initialized, token_rewards_admin, token_alloc_points, protocol_rewards_admin, protocol_alloc_points);
      return action;
    }

    ;;  < amount_a Gram, amount_b Gram, token_address_a uint256, token_address_b uint256 ,slipage int32, b>
    if (action == 1) { ;; transfer
      to = cs~load_bits(264);
      value = cs~load_grams();
      ;; claim rewards by sender before moving lps, timestamp resets after transfer.
      int rewards = balances~claim_rewards(sender, token_alloc_points, protocol_alloc_points, total_supply, token_reserves);
      send_token_to(token_address, sender, rewards, 1);

      storage_fee += balances~transfer(sender, to, value);
      return_value = 1;
    } elseif (action == 2) { ;; transfer_from

      slice from = cs~load_bits(264);
      to = cs~load_bits(264);
      value = cs~load_grams();
      ;; claim rewards by sender before moving lps, timestamp resets after transfer.
      int rewards = balances~claim_rewards(sender, token_alloc_points, protocol_alloc_points, total_supply, token_reserves);
      send_token_to(token_address, sender, rewards, 1);

      storage_fee += allowances~change_allowance(from, sender, - value, 1);
      storage_fee += balances~transfer(from, to, value);
      return_value = 2;
    } elseif (action == 3) { ;; increase/decrease allowance

      sign = cs~load_uint(1);
      slice spender = cs~load_bits(264);
      to = spender;
      int delta_value = cs~load_grams();
      int exact = cs~load_uint(1);

      storage_fee += allowances~change_allowance(sender, spender, sign ? - delta_value : delta_value, exact);
      return_value = 3;
    } elseif (action == op::claim_rewards() ) {
      ;; TODO add reward_rate is a memroy parm
      int rewards = balances~claim_rewards(sender, token_alloc_points, protocol_alloc_points, total_supply, token_reserves);
      send_token_to(token_address, sender, rewards, 1);
      return_value = rewards;
    }  elseif (action == op::remove_liquidity() ) { ;; Remove liquidty

        int amount_to_remove = cs~load_grams();
        int user_balance = _get_balance(balances, sender);
        throw_if( 104, user_balance < amount_to_remove);

        int rewards = balances~claim_rewards(sender, token_alloc_points, protocol_alloc_points, total_supply, token_reserves);
        send_token_to(token_address, sender, rewards, 1);

        (balances, int fee, total_supply, token_reserves, ton_reserves, int users_new_ton) = _burn_liquidity(balances, sender, amount_to_remove, total_supply, ton_reserves, token_reserves, token_address, query_id);
        storage_fee += fee;
        return_value = users_new_ton;
    }  elseif ( action == op::swap_in() ) { ;; TON -> TRC20

      int min_amount_out = cs~load_grams();
      return_value = swapTokens(min_amount_out, msg_value, true, sender);
      ;; Handle revert (maybe thorugh expection is enough to return TONS)

      ;; TODO  add equal_slices(token_address ,sender)
    } elseif ( action == op::update_token_data() ) {
      (int t_wc, int t_addr) = parse_std_addr(token_rewards_admin);
      throw_unless( 401 , ( (t_addr == sender_addr) & (t_wc == sender_wc) ) );
      token_alloc_points = cs~load_grams();
      return_value = token_alloc_points;
    } elseif ( action == op::update_protocol_data() ) {
      (int p_wc, int p_addr) = parse_std_addr(protocol_rewards_admin);
      throw_unless( 402 , ( (p_addr == sender_addr) & (p_wc == sender_wc) ) );
      protocol_alloc_points = cs~load_grams();
      return_value = protocol_alloc_points;
    } elseif ( ( ( action == op::transfer_recipt() ) | ( action == op::transfer_from_recipt() ) )  ) {  ;; TRC20 RECIPTS and validate source token
        slice trc_sender = cs~load_bits(264);
        int trc_amount = cs~load_grams();

        ;; This trick is to parse a builder form the slice (cs~store_builder) so we can read the buffer overload
        cs = cs~load_bits(cs.slice_bits());
        int sub_op = cs~load_uint(8);

        if (sub_op == op::add_liquidity() ) {
            int slipage = cs~load_uint(64);
            throw_if(98, 0 >= trc_amount);
            throw_if(99, 0 >= msg_value);

            if ( token_reserves > 0 ) {
                int msg_price = trc_amount / msg_value;
                int price_delta =  ( ( msg_price / (token_reserves / ton_reserves) ) - 1 ) * 100;
                throw_if(103,  price_delta > slipage );
            }

            int rewards = balances~claim_rewards(trc_sender, token_alloc_points, protocol_alloc_points, total_supply, token_reserves);
            send_token_to(token_address, trc_sender, rewards, 1);
            (balances, total_supply, token_reserves, ton_reserves, int fee) = mint_lp(balances, trc_sender, msg_value, trc_amount, token_reserves, ton_reserves, total_supply);
            int newliq = _get_balance(balances, trc_sender);
            return_value = newliq;
            storage_fee += fee;
        } elseif (sub_op == op::swap_out() ) {  ;; swap TRC20 -> TON
          ;; <b 10TON , min_amount_out=99 b>
          int min_amount_out = cs~load_grams();
          return_value = swapTokens(min_amount_out, trc_amount, false, trc_sender);
          ;; TODO  Handle revert (make sure in case of min amount out doesnt meet , the bounced message returns funds)
        }
    }

    store_data(name, symbol, decimals, total_supply, token_reserves, ton_reserves, balances, allowances, token_address, initialized, token_rewards_admin, token_alloc_points, protocol_rewards_admin, protocol_alloc_points);
    ;; ensure that receipt carries at least 10k gas


    ;;(int cells, int bits, int refs) = cs.slice_compute_data_size(10);

    ;; msg value has enough coins to pay for
    ;;  1) storing cells created during tx plus
    ;;  2) this tx gas costs
    ;;  3) 10k gas for processing of outcoming message
    ;;  4) forward fee for outcoming message

    ;;throw_unless(111, msg_value > storage_fee + gas_to_coins(chain_id, gas_limit + 10000) + msg_fwd_price(cells, bits, chain_id));

    if( action < 4) { ;; send recipts only for trc20 actions
      send_receipt(to,
                   action, query_id,
                   sender,
                   sign, 0,
                   10000000, ;; TODO fix gas 0.01TON fees for message.
                   begin_cell().store_slice(cs));
    }
    return return_value;
}

() recv_external(slice in_msg) impure {
    (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, slice token_rewards_admin, int token_alloc_points, slice protocol_rewards_admin, int protocol_alloc_points) = load_data(get_data());
    throw_unless(60, initialized == 0);
    accept_message();
    store_data(name, symbol, decimals, total_supply, token_reserves, ton_reserves, new_dict(), new_dict(), token_address, 1, token_rewards_admin, token_alloc_points, protocol_rewards_admin, protocol_alloc_points);
}




;;======================== TRC20  ======================================

(slice, slice, int, int, int, int, slice, int) get_token_data() method_id {
  (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, _, _, slice token_address, int initialized, _, _, _, _) = load_data(get_data());
  return (name, symbol, decimals, total_supply, token_reserves, ton_reserves, token_address, initialized);
}



;; Returns the account balance of another account with address _owner.
int balance_of(slice owner) method_id {
  (_, _, _, _, _, _, cell balances, _, _, _, _, _, _, _) = load_data(get_data());
  return _get_balance(balances, owner);
}

int allowance(slice owner, slice spender) method_id {
  (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, _, _ , _, _) = load_data(get_data());
  return _get_allowance(allowances, owner, spender);
}

;;====================== DEX Helpers =====================================

var get_amount_out_lp(int amount_in, int is_token_src) method_id {
  (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, _, _ , _, _) = load_data(get_data());
  int amountInWithFee = amount_in * 997;
  int reserveIn = is_token_src ? token_reserves : ton_reserves;
  int reserveOut = is_token_src ? ton_reserves : token_reserves;
  int numerator =  amountInWithFee * reserveOut;
  int denominator = (reserveIn * 1000) + amountInWithFee;
  return numerator / denominator;
}

var get_amount_in_lp(int amount_out, int is_token_src) method_id {
  (slice name, slice symbol, int decimals, int total_supply, int token_reserves, int ton_reserves, cell balances, cell allowances, slice token_address, int initialized, _, _ , _, _) = load_data(get_data());
  int reserveIn = is_token_src ? token_reserves : ton_reserves;
  int reserveOut = is_token_src ? ton_reserves : token_reserves;

  int numerator =  reserveIn * amount_out * 1000;
  int denominator = (reserveOut - amount_out) * 997;
  return ( numerator / denominator ) + 1;
}

(int, int, int, int, int, int) get_admin_data() method_id {
  (_, _, _, _, _, _, _, _, _, _, slice token_admin_addr, int token_alloc_points, slice protocol_admin_addr, int protocol_alloc_points) = load_data(get_data());
  (int token_admin_wc, int token_admin) = parse_std_addr(token_admin_addr);
  (int protocol_admin_wc, int protocol_admin) = parse_std_addr(protocol_admin_addr);
  return( token_admin_wc, token_admin, token_alloc_points, protocol_admin_wc, protocol_admin, protocol_alloc_points);
}


int ibalance_of(int owner_wc, int owner_addr) method_id {
  slice owner = begin_cell().store_int(owner_wc, 8).store_uint(owner_addr, 256).end_cell().begin_parse();
  return balance_of(owner);
}

int get_rewards_of(int owner_wc, int owner_addr) method_id {
  
  slice owner = begin_cell().store_int(owner_wc, 8).store_uint(owner_addr, 256).end_cell().begin_parse();
  (_, _, _, int total_supply, int token_reserves, _, cell balances, _, _, _, _, int token_alloc_points ,_ ,int protocol_reward_rate) = load_data(get_data());
  (slice liquidity_slice, int found) = balances.dict_get?(264, owner);
  if (found) {  
    (int user_rewards, _) = calc_rewards(liquidity_slice, total_supply, token_reserves, token_alloc_points, protocol_reward_rate);
    return user_rewards;
  }
  return 0;
}