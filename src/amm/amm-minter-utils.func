;; =============  Using babylonian method for Math.sqrt
int squareRoot(int number)  {
    if(number < 3) {
      return 1;
    }
    int lo = 0;
    int hi = number;
    while( lo <= hi ) {
         var mid = (lo + hi) / 2;
         if( mid * mid > number) {
           hi = mid - 1;
         } else {
           lo = mid + 1;
         } 
    }
    return hi;
}

() send_grams(slice address, int amount) impure {
    cell msg = begin_cell()
        .store_uint (0x18, 6)
        .store_slice(address) ;; 267bit address
        .store_grams(amount)
        .store_uint(0, 107) ;; 106 zeroes +  0 as an indicator that there is no cell with the data.
        .end_cell(); 
    send_raw_message(msg, 3); ;; mode, 2 for ignoring errors, 1 for sender pays fees, 64 for returning inbound message value
}

;;transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
;;           response_destination:MsgAddress custom_payload:(Maybe ^Cell)
;;           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
;;           = InternalMsgBody;


      

() send_tokens(int query_id, slice jetton_wallet_address, slice to, int jetton_amount) impure {
     var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(jetton_wallet_address)
    .store_coins(0)
    .store_uint(3 , 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1); ;; 3 bits on 107 length message_body is a ref (message body is in a seperate cell)
     
    var msg_body = begin_cell()
    .store_uint(op::transfer(), 32)
    .store_uint(query_id, 64)
    .store_coins(jetton_amount)
    .store_slice(to)
    .store_slice(to)
    .store_uint(0, 1) ;; null custom_payload
    .store_coins(0) ;; 0 forward_ton_amount
    .store_uint(0, 1) ;; bit is on - empty forward payload 
    .end_cell();

    msg = msg.store_ref(msg_body); ;; 3bits on 107 length  

    send_raw_message(msg.end_cell(), 64); ;; revert on errors
}

int get_amount_out(int amountIn, int reserveIn, int reserveOut) method_id {
  int amountInWithFee = amountIn * 997; ;; lp fees 0.3% 
  int numerator =  amountInWithFee * reserveOut;
  int denominator = reserveIn * 1000 + amountInWithFee;
  return numerator / denominator;
}

(int, int) swapTokens (int min_amount_out, int transferd_amount, int is_ton_src, slice swap_sender, int ton_reserves, int token_reserves, slice token_wallet_address) impure {

    int src_resvers = is_ton_src == true ? ton_reserves : token_reserves;
    int trgt_resvers = is_ton_src == true ? token_reserves : ton_reserves;  

    int amount_out = get_amount_out( transferd_amount, src_resvers, trgt_resvers);
    throw_if(601, amount_out < min_amount_out);

    if(is_ton_src == true) {
      
      ton_reserves = src_resvers + transferd_amount;
      token_reserves = trgt_resvers - amount_out;
        ;;TODO add queryId
      send_tokens(0, token_wallet_address, swap_sender, amount_out);
    } else {
      
      ton_reserves = trgt_resvers - amount_out;
      token_reserves = src_resvers + transferd_amount;
      send_grams(swap_sender, amount_out);
    }
    
    return (ton_reserves, token_reserves);
}


(int, int, int, int) mint_lp(int price, int ton_amount, int token_amount, int ton_reserves, int token_reserves, int total_lp_supply) impure {
    
    int new_liquidity = 0;
    int MINIMUM_LIQUIDITY = 1; ;; TODO IT SHOULD BE 1000 

    ;; TODO fix handle liquidtiy supply on its own param
    if( token_reserves == 0 ) {
      ;; calc the user share  Sushi (Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);)
      new_liquidity = squareRoot(ton_amount * token_amount) / MINIMUM_LIQUIDITY;
    } else {
      ;; liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
      int ton_share = (ton_amount * total_lp_supply) / ton_reserves;
      int token_share = (token_amount * total_lp_supply) / token_reserves;
      new_liquidity = min(ton_share, token_share);
    }

    token_reserves = token_amount + token_reserves;
    ton_reserves = ton_amount + ton_reserves;
    total_lp_supply = new_liquidity + total_lp_supply;    
    return (new_liquidity, total_lp_supply, ton_reserves, token_reserves);
 }

(int) calc_rewards_seconds(int seconds_staked, int reward_rate, int lp_amount, int token_reserves, int total_supply) {
    
    int daily_rewards =  token_reserves * reward_rate;
    int reward_per_second = daily_rewards / (3600 * 24);
    int period_rewards = reward_per_second * seconds_staked;
    return (period_rewards * lp_amount) / total_supply;
}


(slice, int, slice, int) unpack_admin_data(cell admin_data) {
    slice cs = admin_data.begin_parse();
    slice rewards_wallet_address = cs~load_msg_addr();
    int rewards_rate = cs~load_uint(64);
    slice protocol_rewards_wallet_address = cs~load_msg_addr();
    int protocol_rate = cs~load_uint(64);
    return (rewards_wallet_address, rewards_rate, protocol_rewards_wallet_address, protocol_rate);
}

;;this method is optimistic, the amm is the owner
() send_rewards(int query_id, int total_supply, int ton_reserves, int token_reserves, cell admin_data, slice rewards_owner ,int lp_amount ,int seconds_staked) impure {
    
    (slice rewards_wallet_address, int rewards_rate, slice protocol_rewards_wallet_address, int protocol_rate) = unpack_admin_data(admin_data);
    int token_rewards = calc_rewards_seconds(seconds_staked, rewards_rate, lp_amount, token_reserves, total_supply);
    int protocol_rewards = calc_rewards_seconds(seconds_staked, protocol_rate, lp_amount, token_reserves, total_supply);
    if token_rewards > 0 {
        send_tokens(query_id, rewards_wallet_address, rewards_owner, token_rewards);
    }
    if protocol_rewards > 0 {
        send_tokens(query_id, protocol_rewards_wallet_address, rewards_owner, token_rewards);
    }
}

