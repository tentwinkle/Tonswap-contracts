;; Jettons minter smart contract

;; storage scheme
;; storage#_ total_supply:Coins token_wallet_address:MsgAddress content:^Cell jetton_wallet_code:^Cell = Storage;

(int, slice, int, int, cell, cell, cell) load_data() inline {
  slice ds = get_data().begin_parse();
  return (
      ds~load_coins(),      ;; total_supply
      ds~load_msg_addr(),   ;; token_wallet_address
      ds~load_coins(),      ;; ton_reserves
      ds~load_coins(),      ;; token_reserves
      ds~load_ref(),        ;; content
      ds~load_ref(),        ;; jetton_wallet_code
      ds~load_ref()         ;; admin_data
  );
}

() save_data(int total_supply, slice token_wallet_address, int ton_reserves, int token_reserves, cell content, cell jetton_wallet_code, cell admin_data) impure inline {
  set_data(begin_cell()
            .store_coins(total_supply)
            .store_slice(token_wallet_address)
            .store_coins(ton_reserves)
            .store_coins(token_reserves)
            .store_coins(total_supply)
            .store_ref(content)
            .store_ref(jetton_wallet_code)
            .store_ref(admin_data)
           .end_cell()
          );
}



() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
  slice addr = my_address();
  
  ;; hack second to_address should be my_address() cause it doesnt work on tvm (ton-contract-executor)
  cell state_init = calculate_jetton_wallet_state_init(to_address, to_address, jetton_wallet_code);
  slice to_wallet_address = calculate_jetton_wallet_address(state_init);
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(to_wallet_address)
    .store_coins(amount)
    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
    .store_ref(state_init)
    .store_ref(master_msg);
  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();
  
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    (int total_supply, slice token_wallet_address, int ton_reserves, int token_reserves, cell content, cell jetton_wallet_code, cell admin_data) = load_data();

  ;;  if (op == op::mint()) {
  ;;      throw_unless(73, equal_slices(sender_address, token_wallet_address));
  ;;      slice to_address = in_msg_body~load_msg_addr();
  ;;      int amount = in_msg_body~load_coins();
  ;;      cell master_msg = in_msg_body~load_ref();
  ;;      slice master_msg_cs = master_msg.begin_parse();
  ;;      master_msg_cs~skip_bits(32 + 64); ;; op + query_id
  ;;      int jetton_amount = master_msg_cs~load_coins();
  ;;      mint_tokens(to_address, jetton_wallet_code, amount, master_msg, token_wallet_address);
  ;;      save_data(total_supply + jetton_amount, token_wallet_address, ton_reserves, token_reserves, content, jetton_wallet_code);
  ;;      return ();
  ;;  }

    if (op == op::burn_notification()) {
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        int share_on_lp = total_supply / jetton_amount;
        int share_in_ton_reserves = (jetton_amount * ton_reserves) / total_supply;
        int share_in_token_reserves = (jetton_amount * token_reserves) / total_supply;

        send_tokens(0, token_wallet_address, from_address, share_in_token_reserves);        
        send_grams(from_address ,share_in_ton_reserves);
;;TODO fix
;;        throw_unless(74,
;;            equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), jetton_wallet_code), sender_address)
;;        );
        save_data(total_supply - jetton_amount, token_wallet_address, ton_reserves - share_in_ton_reserves, token_reserves - share_in_token_reserves, content, jetton_wallet_code, admin_data);
        
        return ();
    }

    if (op == op::swap_ton() ) {
        int ton_to_swap = in_msg_body~load_coins();
        int min_amount_out = in_msg_body~load_coins();
        throw_if(600, min_amount_out > token_reserves); ;;insufficent liquidity

        (ton_reserves, token_reserves) = swapTokens(min_amount_out, ton_to_swap, true, sender_address, ton_reserves, token_reserves, token_wallet_address);
        save_data(total_supply, token_wallet_address, ton_reserves, token_reserves, content, jetton_wallet_code, admin_data);
        return ();
    }


    ;; transfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16) 
    ;;                          sender:MsgAddress forward_payload:(Either Cell ^Cell)
    ;;                          = InternalMsgBody

    if (op == op::transfer_notification() ) {
      int jetton_amount = in_msg_body~load_coins();
      slice jetton_sender = in_msg_body~load_msg_addr();
      int noPayload = in_msg_body~load_uint(1); 
      
      if (noPayload == -1 ) {
        return ();
      }
      int sub_op = in_msg_body~load_uint(32);

      if( sub_op == op::add_liquidity() ) {

          int slipage = in_msg_body~load_uint(32);
          throw_if(98, 0 >= jetton_amount);
          throw_if(99, 0 >= msg_value);

          int msg_price = jetton_amount / msg_value;
          int reserves_price = 0;
          int price_delta = 0;
          
          if ( token_reserves > 0 ) {
            reserves_price = token_reserves / ton_reserves;
            price_delta =  ( ( msg_price / reserves_price ) - 1 ) * 100;
            throw_if(103,  price_delta > slipage );
          }

          (int new_liquidity, total_supply, ton_reserves, token_reserves) = mint_lp(reserves_price, msg_value ,jetton_amount ,ton_reserves, token_reserves, total_supply);
                                                                       ;;TODO should put null instead of payload
          ;; end wallet is expecting the amount and owner,
          cell mint_msg = begin_cell()
            .store_uint(op::internal_transfer(), 32)
            .store_uint(query_id, 64)
            .store_coins(new_liquidity)
            .store_slice(jetton_sender) ;; TODO should put null here to statisfy address slot
            .store_slice(jetton_sender) ;; TODO should put null here to statisfy address slot
            .store_coins(0)
            .store_uint(0, 1)
            .end_cell();

          mint_tokens(jetton_sender, jetton_wallet_code, new_liquidity, mint_msg);
          save_data(total_supply, token_wallet_address, ton_reserves, token_reserves, content, jetton_wallet_code, admin_data);
          return ();

      }

      if (sub_op == op::swap_token() ) {  ;; swap TRC20 -> TON
          ;; <b 10TON , min_amount_out=99 b>
          int min_amount_out = in_msg_body~load_grams();
          (ton_reserves, token_reserves) = swapTokens(min_amount_out, jetton_amount, false, jetton_sender, ton_reserves, token_reserves, token_wallet_address);
          save_data(total_supply, token_wallet_address, ton_reserves, token_reserves, content, jetton_wallet_code, admin_data);
          return ();
      }
      return ();
    }

    if (op == op::claim_rewards_notification() ) {
        slice rewards_owner = in_msg_body~load_msg_addr();
        int balance = in_msg_body~load_grams();
        int seconds_staked = in_msg_body~load_uint(64);
        send_rewards(query_id, total_supply, ton_reserves, token_reserves, admin_data,rewards_owner, balance, seconds_staked);
        
        return ();
    }

      ;;throw_unless(74,
      ;;      equal_slices(calculate_user_jetton_wallet_address(jetton_sender, my_address(), jetton_wallet_code), sender_address)
      ;;  );


    
    ;; TODO remove liquidity 

    throw(0xffff);
}


() send_transfer_token_message(int query_id, slice jetton_wallet_address, slice to, int jetton_amount) {

     var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(jetton_wallet_address)
    .store_coins(0)
    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
    .store_ref(null());
     
    var msg_body = begin_cell()
    .store_uint(op::transfer(), 32)
    .store_uint(query_id, 64)
    .store_coins(jetton_amount)
    .store_slice(to)
    .store_slice(to)
    .store_coins(0)
    .store_slice(null())
    .end_cell();

    msg = msg.store_ref(msg_body);

    send_raw_message(msg.end_cell(), 64); ;; revert on errors
}


(int, int, slice, int, int, cell, cell, cell) get_jetton_data() method_id {
    (int total_supply, slice token_wallet_address, int ton_reserves, int token_reserves, cell content, cell jetton_wallet_code, cell admin_data) = load_data();
    return (total_supply, -1, token_wallet_address, ton_reserves, token_reserves, content, jetton_wallet_code, admin_data);
}

slice get_wallet_address(slice owner_address) method_id {
    (int total_supply, slice token_wallet_address, int ton_reserves, int token_reserves, cell content, cell jetton_wallet_code, _) = load_data();
    return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);
}

(int, int) get_rewards_by(int lp_amount, int seconds_staked) method_id {
    (int total_supply, _, _, int token_reserves, _, _, cell admin_data) = load_data();
    (_, int rewards_rate, _, int protocol_rate) = unpack_admin_data(admin_data);
    int token_rewards = calc_rewards_seconds(seconds_staked, rewards_rate, lp_amount, token_reserves, total_supply);
    int protocol_rewards = calc_rewards_seconds(seconds_staked, protocol_rate, lp_amount, token_reserves, total_supply);
    
    return (token_rewards, protocol_rewards);
}