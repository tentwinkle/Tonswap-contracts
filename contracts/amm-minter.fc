#include "stdlib.fc";
#include "op-codes.fc";
#include "op-codes-amm.fc";
#include "params.fc";
#include "jetton-utils.fc"; ;; https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-utils.fc
#include "amm-minter-utils.fc";



const MIN_JETTON_STORAGE = 10000000;     ;; 0.01 TON
const JETTON_GAS_COMPUTATION = 10000000; ;; 0.01 TON
const ADD_LIQUIDTY_DUST = 100000000;     ;; 0.1 
const zerro_address = "EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c"a;
const MAX_SLIPAGE = 99; ;; TODO

;; storage#_ total_supply:Coins token_wallet_address:MsgAddress ton_reserves:Coins 
;; token_reserves:Coins admin:MsgAddress content:^Cell jetton_wallet_code:^Cell = Storage;

(int, slice, int, int, slice, cell, cell) load_data() inline {
  slice ds = get_data().begin_parse();
  
  return (
      ds~load_coins(),      ;; total_supply
      ds~load_msg_addr(),   ;; token_wallet_address
      ds~load_coins(),      ;; ton_reserves
      ds~load_coins(),      ;; token_reserves
      ds~load_msg_addr(),      ;; admin
      ds~load_ref(),        ;; content (uri to json)
      ds~load_ref()         ;; jetton_wallet_code
  );
}

() save_data(int total_supply,
             slice token_wallet_address,
             int ton_reserves,
             int token_reserves,
             slice admin,
             cell content,
             cell jetton_wallet_code) impure inline {

  set_data(begin_cell()
               .store_coins(total_supply)
               .store_slice(token_wallet_address)
               .store_coins(ton_reserves)
               .store_coins(token_reserves)
               .store_slice(admin)
               .store_ref(content)
               .store_ref(jetton_wallet_code)
               .end_cell());
}


() mint_tokens(slice to_address, int query_id, cell jetton_wallet_code, int amount, int ton_leftovers) impure {
  
      ;; end wallet is expecting the amount and owner,
    cell mint_msg = begin_cell()
    .store_uint(OP_INTERNAL_TRANSFER, 32)
    .store_uint(query_id, 64)
    .store_coins(amount)
    .store_slice(to_address) ;; 
    .store_slice(to_address) ;; response_destination -> the address should get the jetton leftovers via #Excesses
    .store_coins(0)
    .store_uint(0, 1)
    .end_cell();

  cell state_init = calculate_jetton_wallet_state_init(
    to_address, 
    my_address(), 
    jetton_wallet_code
  );

  slice to_wallet_address = calculate_jetton_wallet_address(state_init);
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(to_wallet_address)
    .store_coins(ton_leftovers)
    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
    .store_ref(state_init)
    .store_ref(mint_msg);
  
  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}


() add_liquidity(slice in_msg_body,
                 int jetton_amount,
                 slice jetton_sender,
                 int msg_value,
                 slice sender_address,
                 int fwd_fee,
                 int query_id) impure {

  (int total_supply,
    slice token_wallet_address,
    int ton_reserves,
    int token_reserves,
    slice admin,
    cell content,
    cell jetton_wallet_code) = load_data();

  int slippage = in_msg_body~load_uint(32);
  int ton_liquidity = in_msg_body~load_grams();
  if (0 == jetton_amount) | (msg_value == 0) | slippage > MAX_SLIPAGE {
    revert_add_liquidity(ton_liquidity,
                        jetton_amount,
                        token_wallet_address,
                        jetton_sender,
                        query_id, msg_value);
    return ();
  }

  ;; min jetton storage for the lp wallet plus 1 message for mint 1
  int gas_cost = (fwd_fee * 2) + (JETTON_GAS_COMPUTATION * 2) + MIN_JETTON_STORAGE;
  
  ;;   ton liquidity should cover jettonStorage+ fwd fee for the mint message
  if ( ton_liquidity > msg_value - gas_cost ) | ton_liquidity < ADD_LIQUIDTY_DUST  {
    revert_add_liquidity(ton_liquidity,
                  jetton_amount,
                  token_wallet_address,
                  jetton_sender,
                  query_id,
                  msg_value);
    return ();
  }

  

  int should_revert = 0;

  if ton_reserves > 0 {
    int optimal_ton = quote(jetton_amount, token_reserves, ton_reserves);
    int optimal_jetton = quote(ton_liquidity, ton_reserves, token_reserves);

    int ton_liquidity_min = muldiv(ton_liquidity, ( 100 - slippage ), 100);
    int jeton_liquidity_min = muldiv(jetton_amount, ( 100 - slippage ), 100);

    if( ( optimal_ton <= ton_liquidity_min ) | (optimal_jetton <= jeton_liquidity_min) ) {
        revert_add_liquidity(ton_liquidity,
                  jetton_amount,
                  token_wallet_address,
                  jetton_sender,
                  query_id,
                  msg_value);
        should_revert = 1;
    } else {
        int extra_ton = ton_liquidity - optimal_ton;
        int extra_jeton = jetton_amount - optimal_jetton;

        ;; return extra's
        if extra_jeton > ADD_LIQUIDTY_DUST {
            transfer_token(query_id, token_wallet_address, jetton_sender, extra_jeton, fwd_fee * 2 );  ;; TODO send 0.1TON use fwd 
            ton_liquidity = optimal_ton;
        }
        elseif extra_ton > ADD_LIQUIDTY_DUST {
            send_grams(jetton_sender ,extra_ton);
   ;;         ton_liquidity = optimal_ton;
        }
    }
  }

  if should_revert == 1 {
    return ();
  }

  (int minted_lp, total_supply, ton_reserves, token_reserves)
    = calculate_new_lp(ton_liquidity, jetton_amount, ton_reserves, token_reserves, total_supply);
  if equal_slices(token_wallet_address, zerro_address) {
    token_wallet_address = sender_address;
  }

  mint_tokens(jetton_sender, query_id, jetton_wallet_code, minted_lp, ( msg_value - ton_liquidity ));
  save_data(total_supply,
    token_wallet_address,
    ton_reserves,
    token_reserves,
    admin,
    content,
    jetton_wallet_code);
  
  return ();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) {
    return ();
  }
  
  slice sender_address = cs~load_msg_addr();

  ;; log_balance(sender_address, my_balance);
  cs~load_msg_addr(); ;; skip dst
  cs~load_coins(); ;; skip value
  cs~skip_bits(1); ;; skip extracurrency collection
  cs~load_coins(); ;; skip ihr_fee
  int fwd_fee = cs~load_coins(); ;; we use message fwd_fee for estimation of forward_payload costs    

  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  (int total_supply,
  slice token_wallet_address,
  int ton_reserves,
  int token_reserves,
  slice admin,
  cell content,
  cell jetton_wallet_code) = load_data();
  
  ;; msg_value = maintain_contract_gas(msg_value, my_balance, ton_reserves);
  

  if (op == OP_BURN_NOTIFICAITON) {
      int jetton_amount = in_msg_body ~load_coins();
      slice from_address = in_msg_body ~load_msg_addr();
      int ton_to_remove = muldiv(jetton_amount, ton_reserves, total_supply);
      int token_to_remove = muldiv(jetton_amount, token_reserves, total_supply);

      throw_unless(74,
        equal_slices(calculate_user_jetton_wallet_address(from_address,my_address(),jetton_wallet_code) 
        ,sender_address)
      );

      send_grams(from_address, ton_to_remove);
      transfer_token(query_id,
              token_wallet_address,
              from_address,
              token_to_remove,
              msg_value);

      save_data(total_supply - jetton_amount,
                token_wallet_address,
                ton_reserves - ton_to_remove,
                token_reserves - token_to_remove,
                admin,
                content,
                jetton_wallet_code);
      
      return ();
  }

  if (op == OP_SWAP_TON ) {
      
    int ton_to_swap = in_msg_body~load_coins();
    int min_amount_out = in_msg_body~load_coins();
    throw_if(600, min_amount_out > token_reserves); ;;insufficent liquidity
    throw_if(601, 0 == token_reserves); ;; insufficent liquidity
    throw_if(602, equal_slices(token_wallet_address, zerro_address) ); ;; pool is not intialized 
    
    int fee = fwd_fee * 2 + TON_TOKEN_SWAP_FEE;
    (ton_reserves, token_reserves) = swapTokens(min_amount_out,
                                        ton_to_swap,
                                        true,
                                        sender_address,
                                        ton_reserves,
                                        token_reserves,
                                        token_wallet_address,
                                        query_id,
                                        msg_value, 
                                        fee);
    save_data(total_supply,
          token_wallet_address,
          ton_reserves,
          token_reserves,
          admin,
          content,
          jetton_wallet_code);
    return ();
  }

  if (op == OP_TRANSFER_NOTIFICATION ) {
    int jetton_amount = in_msg_body~load_coins();
    slice jetton_sender = in_msg_body~load_msg_addr();
    int noPayload = in_msg_body~load_uint(1); 
    if (noPayload == -1 ) {
      return ();
    }

    ;; accept add-liquidity and swap actions only from token_wallet_address
    ;;  if token_wallet_address != null && token_wallet_address != sender_address -> throw
    if (equal_slices(token_wallet_address, zerro_address) == false)
      &(equal_slices(token_wallet_address, sender_address) == false) {
        throw_if(76, true);
    }
    
    int sub_op = in_msg_body~load_uint(32);
    
    if( sub_op == OP_ADD_LIQUIDITY ) {
      add_liquidity(in_msg_body,
            jetton_amount,
            jetton_sender,
            msg_value,
            sender_address,
            fwd_fee,
            query_id);
      return ();
    }

    if (sub_op == OP_SWAP_TOKEN ) {  ;; swap TRC20 -> TON
      ;; bonuce message will be handled properly by the jetton sender
      throw_if(75, equal_slices(token_wallet_address, zerro_address)); 
      int min_amount_out = in_msg_body~load_grams();
      int fee = fwd_fee * 2 + TON_TOKEN_SWAP_FEE;
      (ton_reserves,
        token_reserves) = swapTokens(min_amount_out, jetton_amount, false,
                          jetton_sender, ton_reserves, token_reserves,
                          token_wallet_address, query_id, msg_value, fee);
      
      save_data(total_supply,
          token_wallet_address,
          ton_reserves,
          token_reserves,
          admin,
          content,
          jetton_wallet_code);
      return ();
    }
    return ();
  }

  if (op == OP_CODE_UPGRADE & equal_slices(sender_address, admin) ) {
    cell code = in_msg_body~load_ref();
    set_code(code);
    return ();
  }


  throw(0xffff);
}



(int, int, slice, int, int, slice, cell, cell) get_jetton_data() method_id {
  (int total_supply,
  slice token_wallet_address,
  int ton_reserves,
  int token_reserves,
  slice admin,
  cell content,
  cell jetton_wallet_code) = load_data();
  return (total_supply, -1, token_wallet_address, ton_reserves, token_reserves, admin, content, jetton_wallet_code);
}

slice get_wallet_address(slice owner_address) method_id {
  (int total_supply,
  slice token_wallet_address,
  int ton_reserves,
  int token_reserves,
  slice admin,
  cell content,
  cell jetton_wallet_code) = load_data();
  return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);
}
